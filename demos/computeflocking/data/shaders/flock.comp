// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
#version 450

layout(local_size_x = 8) in;


struct Boid
{
	vec4 position;
	vec4 direction;
	vec4 velocity;

	vec4 avoidanceHeading;
	vec4 flockHeading;
	vec4 flockCenter;

	vec3 padding;
	int numFlockMates;
};


// STORAGE

layout(std430) buffer BoidBuffer_In
{
	Boid boids[2000];
} subo_in;

layout(std430) buffer BoidBuffer_Out
{
	Boid boids[2000];
} subo_out;

layout(std430) buffer VertexBuffer 
{
	vec4 vertices[8000];
};


// UNIFORM

uniform UBO 
{
	vec4 target;
	float deltaTime;
	float elapsedTime;
	float boidSize;
	float viewRadius;
	float avoidRadius;
	float minSpeed;
	float maxSpeed;
	float maxSteerForce;
	float targetWeight;
	float alignmentWeight;
	float cohesionWeight;
	float separationWeight;
	int numBoids;
} ubo;


// CONSTANTS

const vec3 FORWARD = vec3(1.0, 0.0, 0.0);
const vec4 QUAT_IDENTITY = vec4(0.0, 0.0, 0.0, 1.0);
const vec3 X_AXIS = vec3(1.0, 0.0, 0.0);
const vec3 Y_AXIS = vec3(0.0, 1.0, 0.0);
const vec3 Z_AXIS = vec3(0.0, 0.0, 1.0);


// UTILITIES

mat4 translate(vec3 d)
{
	return mat4(
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		d.x, d.y, d.z, 1.0
	);
}


mat4 rotation(vec3 src, vec3 dst)
{
	vec3  v = cross(src, dst);
	float c = dot(src, dst);
	float k = 1.0f/(1.0f+c);

	return mat4(
		v.x*v.x*k + c,		v.y*v.x*k - v.z,	v.z*v.x*k + v.y,	0.0,
		v.x*v.y*k + v.z,	v.y*v.y*k + c,		v.z*v.y*k - v.x,	0.0,
		v.x*v.z*k - v.y,	v.y*v.z*k + v.x,	v.z*v.z*k + c,		0.0,
		0.0,				0.0,				0.0,				1.0
	);
}


mat4 lookAt(vec3 from, vec3 to, vec3 upRef)
{
	vec3 forward = normalize(from - to);    
	vec3 right = cross(forward, normalize(upRef));
	//vec3 right = normalize(cross(forward, vec3(sin(roll.x), cos(roll.x), 0.0)));
	vec3 up = cross(forward, right);

	return mat4(
		right.x,	right.y,	right.z,	-dot(right, from),
		up.x,		up.y,		up.z,		-dot(up, from),
		forward.x,	forward.y,	forward.z,	-dot(forward, from),
		0.0, 		0.0,		0.0,		1.0
	);
}


vec3 clampMagnitude(vec3 v, float min, float max)
{
	if (length(v) > max)
		return normalize(v) * max;
	else if (length(v) < min)
		return normalize(v) * min;

	return v;
}


vec3 steerTowards(vec3 target, vec3 velocity, float maxSpeed)
{
	vec3 v = normalize(target) * maxSpeed - velocity;
	return clampMagnitude(v, length(v), ubo.maxSteerForce);
}


// SHADER MAIN

void main()
{
	uint id = gl_GlobalInvocationID.x;

	// Read current boid
	Boid b = subo_in.boids[id];

	// Reset num flock mates
	b.numFlockMates = 0;

	// Update force variables
	for (int idx = 0; idx < ubo.numBoids; idx++) 
	{
		if (id != idx) 
		{
			vec4 other_position = subo_in.boids[idx].position;
			vec4 other_direction = normalize(subo_in.boids[idx].velocity);

			vec4 offset = other_position - b.position;
			float distance_squared = offset.x * offset.x + offset.y * offset.y + offset.z * offset.z;

			if (distance_squared < ubo.viewRadius * ubo.viewRadius) 
			{
				b.numFlockMates++;
				b.flockHeading += other_direction;
				b.flockCenter += other_position;

				if (distance_squared < ubo.avoidRadius * ubo.avoidRadius)
				{
					b.avoidanceHeading -= offset / distance_squared;
				}
			}
		}
	}

	// Calculate base acceleration
	vec4 offset = ubo.target - b.position;
	vec3 acceleration = steerTowards(offset.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.targetWeight;

	// Calculate forces
	if (b.numFlockMates != 0) 
	{
		vec4 average_flock_center = b.flockCenter / b.numFlockMates;
		vec4 average_flock_heading = b.flockHeading / b.numFlockMates;
		vec4 average_avoidance_heading = b.avoidanceHeading / b.numFlockMates;

		vec3 alignment = steerTowards(average_flock_heading.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.alignmentWeight;
		vec3 cohesion = steerTowards(average_flock_center.xyz - b.position.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.cohesionWeight;
		vec3 seperation = steerTowards(average_avoidance_heading.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.separationWeight;

		acceleration += alignment;
		acceleration += cohesion;
		acceleration += seperation;
	}

	// Write current boid
	vec3 vel = b.velocity.xyz + acceleration * ubo.deltaTime;
	b.velocity = vec4(clampMagnitude(vel, ubo.minSpeed, ubo.maxSpeed), 0.0);
	b.position += b.velocity * ubo.deltaTime;

	subo_out.boids[id] = b;

	// Create the position vertices
	float extent = ubo.boidSize * 0.5;

	// Get rectangle positions
	vec4 edges[4];

	edges[0] = vec4(-extent,	-extent, 	0.0, 1.0);
	edges[1] = vec4(extent,		-extent, 	0.0, 1.0);
	edges[2] = vec4(-extent,	extent, 	0.0, 1.0);
	edges[3] = vec4(extent,		extent, 	0.0, 1.0);

	// Apply particle translation / rotation
	mat4 translation = translate(b.position.xyz);
	mat4 rotation = rotation(FORWARD, normalize(b.velocity.xyz));

	// Vertex storage buffer
	for (int i=0; i<4; i++)
	{
		vertices[gl_GlobalInvocationID.x*4+i] = translation * rotation * edges[i];
	}
}
