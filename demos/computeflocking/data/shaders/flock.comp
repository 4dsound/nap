// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
#version 450

layout(local_size_x = 8) in;

// struct AABB
// {
// 	vec3 position;
// 	vec3 size;
// };

// struct CollisionData
// {
// 	vec4 hit;
// 	vec4 normal;
// 	float minimum;
// 	int collision;
// 	vec2 padding;
// };

struct Boid
{
	vec4 position;
	vec4 velocity;

	vec4 avoidanceHeading;
	vec4 flockHeading;
	vec4 flockCenter;

	// Padding member
	int padding[3];

	// Maintain 16 byte-alignment
	int numFlockMates;
};


// STORAGE

layout(std430) buffer BoidBuffer_In
{
	Boid boids[2000];
} subo_in;

layout(std430) buffer BoidBuffer_Out
{
	Boid boids[2000];
} subo_out;

layout(std430) buffer MatrixBuffer
{
	mat4 transforms[2000];
};


// UNIFORM

uniform UBO 
{
	vec3 target;
	float deltaTime;
	float elapsedTime;
	float viewRadius;
	float avoidRadius;
	float minSpeed;
	float maxSpeed;
	float maxSteerForce;
	float targetWeight;
	float alignmentWeight;
	float cohesionWeight;
	float separationWeight;
	int numBoids;
} ubo;


// CONSTANTS

const float EPSILON = 0.00001;
const vec4 QUAT_IDENTITY = vec4(0.0, 0.0, 0.0, 1.0);
const vec3 FORWARD_AXIS = vec3(0.0, 0.0, -1.0);
const vec3 UP_AXIS = vec3(0.0, 1.0, 0.0);
const vec3 X_AXIS = vec3(1.0, 0.0, 0.0);
const vec3 Y_AXIS = vec3(0.0, 1.0, 0.0);
const vec3 Z_AXIS = vec3(0.0, 0.0, 1.0);


// UTILITIES

// CollisionData rayBox(vec3 orig, vec3 dir, AABB box)
// {
// 	vec3 invdir = vec3(1.0, 1.0, 1.0) / dir;

// 	// Calculate intersections with rectangle bounding axes
// 	vec3 tmin = (box.position - orig) * invdir;
// 	vec3 tmax = (box.position + box.size - orig) * invdir;

// 	// Sort intersection distances
// 	if (tmin.x > tmax.x) 
// 	{
// 		float temp = tmin.x;
// 		tmin.x = tmax.x;
// 		tmax.x = temp;
// 	}

// 	if (tmin.y > tmax.y)
// 	{
// 		float temp = tmin.y;
// 		tmin.y = tmax.y;
// 		tmax.y = temp;
// 	}

// 	CollisionData cd;

// 	if ((tmin.x > tmax.y) || (tmin.y > tmax.x)) return cd;

// 	// Distances to min and max bound collisions
// 	float t_hit_max = min(tmax.x, tmax.y);
// 	if (t_hit_max <= 0) return cd;

// 	cd.minimum = max(tmin.x, tmin.y);
// 	cd.hit = orig + (dir * cd.minimum);

// 	// Calculate pushout normal
// 	if (tmin.x > tmin.y) 
// 	{
// 		if (invdir.x < 0) cd.normal = vec3(1.0, 0.0, 0.0);
// 		else cd.normal = vec3(-1.0, 0.0, 0.0);
// 	}
// 	else if (tmin.x < tmin.y) 
// 	{
// 		if (invdir.y < 0) cd.normal = vec3(0, 1.0, 0.0);
// 		else cd.normal = vec3(0.0, -1.0, 0.0);
// 	}
// 	return cd;
// }


mat4 translate(vec3 d)
{
	return mat4(
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		d.x, d.y, d.z, 1.0
	);
}


mat4 lookAt(vec3 from, vec3 to)
{
	vec3 forward = normalize(to - from);
	vec3 up = UP_AXIS;

	if(abs(forward.x) < EPSILON && abs(forward.z) < EPSILON)
		up = (forward.y > 0.0) ? vec3(0.0, 0.0, -1.0) : vec3(0.0, 0.0, 1.0);
	else
		up = vec3(0.0, 1.0, 0.0);

	//vec3 right = normalize(cross(forward, vec3(sin(roll.x), cos(roll.x), 0.0)));
	vec3 right = normalize(cross(up, forward));
	
	//forward = normalize(cross(right, up));
	up = normalize(cross(forward, right));

	return mat4(
		right.x,	right.y,	right.z,	0.0,
		up.x,		up.y,		up.z,		0.0,
		forward.x,	forward.y,	forward.z,	0.0,
		0.0, 		0.0,		0.0,		1.0
	);
}


bool isZero(vec3 v)
{
	float valid = 1.0;

	valid *= step(-EPSILON, v.x) * (1.0 - step(EPSILON, v.x));
	valid *= step(-EPSILON, v.y) * (1.0 - step(EPSILON, v.y));
	valid *= step(-EPSILON, v.z) * (1.0 - step(EPSILON, v.z));

	return bool(valid);
}


vec3 clampMagnitude(vec3 v, float min, float max)
{
	if (length(v) > max)
		return normalize(v) * max;
	else if (length(v) < min)
		return normalize(v) * min;

	return v;
}


vec3 steerTowards(vec3 targetDir, vec3 velocity, float maxSpeed)
{
	if (isZero(targetDir))
		return velocity;

	vec3 v = normalize(targetDir) * maxSpeed - velocity;
	return clampMagnitude(v, length(v), ubo.maxSteerForce);
}


// SHADER MAIN

void main()
{
	uint id = gl_GlobalInvocationID.x;

	// Read current boid
	Boid b = subo_in.boids[id];

	// Reset num flock mates
	b.numFlockMates = 0;

	// Update force variables
	for (int idx = 0; idx < ubo.numBoids; idx++) 
	{
		if (id != idx) 
		{
			vec4 other_position = subo_in.boids[idx].position;
			vec4 other_direction = normalize(subo_in.boids[idx].velocity);

			vec4 offset = other_position - b.position;
			float distance_squared = offset.x * offset.x + offset.y * offset.y + offset.z * offset.z;

			if (distance_squared < ubo.viewRadius * ubo.viewRadius) 
			{
				b.numFlockMates++;
				b.flockHeading += other_direction;
				b.flockCenter += other_position;

				if (distance_squared < ubo.avoidRadius * ubo.avoidRadius)
				{
					// Note that this value can be (0.0, 0.0, 0.0)
					b.avoidanceHeading -= offset / distance_squared;
				}
			}
		}
	}

	// Calculate base acceleration
	vec4 offset = vec4(ubo.target, 0.0) - b.position;
	vec3 acceleration = steerTowards(offset.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.targetWeight;

	// Calculate forces
	if (b.numFlockMates > 0) 
	{
		vec4 average_flock_center = b.flockCenter / b.numFlockMates;
		vec4 average_flock_heading = b.flockHeading / b.numFlockMates;
		vec4 average_avoidance_heading = b.avoidanceHeading / b.numFlockMates;

		vec3 alignment = steerTowards(average_flock_heading.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.alignmentWeight;
		vec3 cohesion = steerTowards(average_flock_center.xyz - b.position.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.cohesionWeight;
		vec3 seperation = steerTowards(average_avoidance_heading.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.separationWeight;

		acceleration += alignment;
		acceleration += cohesion;
		acceleration += seperation;
	}

	// Write current boid
	vec3 vel = clampMagnitude(b.velocity.xyz + acceleration * ubo.deltaTime, ubo.minSpeed, ubo.maxSpeed);
	b.velocity = mix(vec4(vel, 0.0), b.velocity, 0.5);
	b.position += b.velocity * ubo.deltaTime;

	subo_out.boids[id] = b;

	// Calculate transformation matrices
	// Apply particle translation / rotation
	mat4 translation = translate(b.position.xyz);
	mat4 rotation = lookAt(FORWARD_AXIS, normalize(b.velocity.xyz));

	// Matrix storage buffer
	transforms[id] = translation * rotation;
}
