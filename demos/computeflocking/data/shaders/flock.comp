// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
#version 450

layout(local_size_x = 32) in;

struct Boid
{
	vec4 position;
	vec4 velocity;
	vec4 direction;

	vec4 avoidanceHeading;
	vec4 flockHeading;
	vec4 flockCenter;

	// Padding member
	int padding[3];

	// Maintain 16 byte-alignment
	int numFlockMates;
};

struct BoidTransform
{
	vec4 translation;
	vec4 rotation;
};


// STORAGE
layout(std430) buffer BoidBuffer_In
{
	Boid boids[1000];
} subo_in;

layout(std430) buffer BoidBuffer_Out
{
	Boid boids[1000];
} subo_out;

layout(std430) buffer TransformBuffer
{
	BoidTransform transforms[1000];
};


// UNIFORM
uniform UBO 
{
	vec3 target;
	float deltaTime;
	float elapsedTime;
	float viewRadius;
	float avoidRadius;
	float minSpeed;
	float maxSpeed;
	float maxSteerForce;
	float targetWeight;
	float alignmentWeight;
	float cohesionWeight;
	float separationWeight;
	int numBoids;
} ubo;


// CONSTANTS
const float PI = 3.141592;
const float EPSILON = 0.00001;
const vec4 QUAT_IDENTITY = vec4(0.0, 0.0, 0.0, 1.0);
const vec3 FORWARD_AXIS = vec3(0.0, 0.0, 1.0);


// Returns a quaterion describing a rotation of angle radians over the specified axis
// Ported from glm::axis
vec4 angleAxisQuat(float angle, vec3 axis)
{
	float s = sin(angle*0.5);
	return vec4(
		axis.x * s,
		axis.y * s,
		axis.z * s,
		cos(angle * 0.5)
	);
}


// Returns a quaternion describing a rotation from orig to dest
// Ported from glm::rotation
vec4 rotationQuat(vec3 orig, vec3 dest)
{
	float cos_theta = dot(orig, dest);
	vec3 rot_axis;

	if (cos_theta >= 1.0-EPSILON)
		return QUAT_IDENTITY;

	if (cos_theta < -1.0+EPSILON)
	{
		rot_axis = cross(vec3(0.0, 0.0, 1.0), orig);
		if (dot(rot_axis, rot_axis) < EPSILON)
			rot_axis = cross(vec3(1.0, 0.0, 0.0), orig);

		rot_axis = normalize(rot_axis);
		return angleAxisQuat(PI, rot_axis);
	}

	rot_axis = cross(orig, dest);

	float s = sqrt((1.0 + cos_theta) * 2.0);
	float inv = 1.0/s;

	return vec4(
		rot_axis.x * inv,
		rot_axis.y * inv,
		rot_axis.z * inv,
		s * 0.5
	);
}


// Returns true if v is a zer-vector, otherwise false
bool isZero(vec3 v)
{
	float valid = 1.0;

	valid *= step(-EPSILON, v.x) * (1.0 - step(EPSILON, v.x));
	valid *= step(-EPSILON, v.y) * (1.0 - step(EPSILON, v.y));
	valid *= step(-EPSILON, v.z) * (1.0 - step(EPSILON, v.z));

	return bool(valid);
}


// Clamps the magnitude of v between min and max
vec3 clampMagnitude(vec3 v, float min, float max)
{
	if (length(v) > max)
		return normalize(v) * max;
	else if (length(v) < min)
		return normalize(v) * min;

	return v;
}


// Cheap linear interpolation
vec3 steerTowards(vec3 targetDir, vec3 velocity, float maxSpeed)
{
	if (isZero(targetDir))
		return velocity;

	vec3 v = normalize(targetDir) * maxSpeed - velocity;
	return clampMagnitude(v, length(v), ubo.maxSteerForce);
}


// SHADER MAIN
void main()
{
	uint id = gl_GlobalInvocationID.x;

	// Read current boid
	Boid b = subo_in.boids[id];

	// Reset num flock mates
	b.numFlockMates = 0;

	// Update force variables
	for (int idx = 0; idx < ubo.numBoids; idx++) 
	{
		if (id != idx) 
		{
			vec4 other_position = subo_in.boids[idx].position;
			vec4 other_direction = normalize(subo_in.boids[idx].velocity);

			vec4 offset = other_position - b.position;
			float l1 = dot(offset.xyz, offset.xyz);

			if (l1 < ubo.viewRadius * ubo.viewRadius) 
			{
				b.numFlockMates++;
				b.flockHeading += other_direction;
				b.flockCenter += other_position;

				if (l1 < ubo.avoidRadius * ubo.avoidRadius)
				{
					// Note that this can be a zero vector
					b.avoidanceHeading -= offset / l1;
				}
			}
		}
	}

	// Calculate base acceleration
	vec4 offset = vec4(ubo.target, 0.0) - b.position;
	vec3 acceleration = steerTowards(offset.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.targetWeight;

	// Calculate forces
	if (b.numFlockMates > 0) 
	{
		vec4 average_flock_center = b.flockCenter / b.numFlockMates;
		vec4 average_flock_heading = b.flockHeading / b.numFlockMates;
		vec4 average_avoidance_heading = b.avoidanceHeading / b.numFlockMates;

		vec3 alignment = steerTowards(average_flock_heading.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.alignmentWeight;
		vec3 cohesion = steerTowards(average_flock_center.xyz - b.position.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.cohesionWeight;
		vec3 seperation = steerTowards(average_avoidance_heading.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.separationWeight;

		acceleration += alignment;
		acceleration += cohesion;
		acceleration += seperation;
	}

	// Write current boid
	vec3 vel = clampMagnitude(b.velocity.xyz + acceleration * ubo.deltaTime, ubo.minSpeed, ubo.maxSpeed);
	
	if (!isZero(vel))
		b.velocity = mix(vec4(vel, 0.0), b.velocity, 0.5);

	b.direction = vec4(steerTowards(b.direction.xyz, b.velocity.xyz, 0.005), 0.0);
	b.position += b.velocity * ubo.deltaTime;

	subo_out.boids[id] = b;

	// Create boid transform
	BoidTransform bt;
	bt.translation = b.position;

	// Calculate quaternion describing a rotation from the forward direction to the current direction
	bt.rotation = rotationQuat(FORWARD_AXIS, normalize(b.direction.xyz));

	// Set boid transform
	transforms[id] = bt;
}
