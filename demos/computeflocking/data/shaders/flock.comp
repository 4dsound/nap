// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
#version 450

layout(local_size_x = 256) in;

struct Boid
{
	vec4 position;
	vec4 velocity;
	vec4 orientation;

	vec4 avoidanceHeading;
	vec4 flockHeading;
	vec4 flockCenter;

	// Padding member
	uint padding[3];

	// Maintain 16 byte-alignment
	uint numFlockMates;
};

// STORAGE
layout(std430) readonly buffer BoidBuffer_In
{
	Boid boids[10000];
} subo_in;

layout(std430) writeonly buffer BoidBuffer_Out
{
	Boid boids[10000];
} subo_out;


// UNIFORM
uniform UBO
{
	vec3 target;
	uint numBoids;
	float deltaTime;
	float elapsedTime;
	float viewRadius;
	float avoidRadius;
	float minSpeed;
	float maxSpeed;
	float maxSteerForce;
	float targetWeight;
	float alignmentWeight;
	float cohesionWeight;
	float separationWeight;
	float boundsExtent;
} ubo;


// CONSTANTS
const float PI 				= 3.141592;
const float EPSILON 		= 0.00001;
const float BIAS 			= 1.0 + EPSILON;
const vec4 QUAT_IDENTITY 	= vec4(0.0, 0.0, 0.0, 1.0);
const vec3 FORWARD 			= vec3(0.0, 0.0, 1.0);
const vec3 UP 				= vec3(0.0, 1.0, 0.0);
const vec3 RIGHT 			= vec3(1.0, 0.0, 0.0);

const float avoidBoundWeightConst = 2.5;

// SHARED
struct BoidData
{
	vec4 pos;
	vec4 vel;
};
shared BoidData sharedData[gl_WorkGroupSize.x];


// Multiply two quaternions -> qa * qb
vec4 mulQuat(vec4 qa, vec4 qb)
{ 
	return normalize(vec4(
		qb.xyz * qa.w + qa.xyz * qb.w + cross(qa.xyz, qb.xyz),
		qa.w * qb.w - dot(qa.xyz, qb.xyz)
	));
}


// Rotate vector v with quaterion q
vec3 rotate(vec3 v, vec4 q)
{
	float l1 = dot(q.xyz, q.xyz);
	return v * (q.w * q.w - l1) + q.xyz * (dot(v, q.xyz) * 2.0) + cross(q.xyz, v) * (q.w * 2.0);
}


// Returns a quaternion describing a rotation from orig to dest
vec4 rotationQuat(vec3 orig, vec3 dest)
{
	float cos_theta = dot(orig, dest);
	if (cos_theta >= 1.0-EPSILON)
		return QUAT_IDENTITY;

	vec3 rot_axis = cross(orig, dest);
	float s = sqrt((1.0+cos_theta)*2.0);
	float invs = 1.0 / s;

	return vec4(
		rot_axis.x * invs,
		rot_axis.y * invs,
		rot_axis.z * invs,
		s * 0.5
	);
}


// Returns true if v is a zero-vector, otherwise false
bool isZero(vec3 v)
{
	float valid = 1.0;

	valid *= step(-EPSILON, v.x) * (1.0 - step(EPSILON, v.x));
	valid *= step(-EPSILON, v.y) * (1.0 - step(EPSILON, v.y));
	valid *= step(-EPSILON, v.z) * (1.0 - step(EPSILON, v.z));

	return bool(valid);
}


// Returns a zero vector instead of nan if v cannot be normalized, otherwise normalizes v
vec3 safeNormalize(vec3 v)
{
	return !isZero(v) ? normalize(v) : vec3(0.0);
}


// Clamps the magnitude of v between min and max
vec3 clampMagnitude(vec3 v, float min, float max)
{
	if (length(v) > max)
		return normalize(v) * max;
	else if (length(v) < min)
		return normalize(v) * min;

	return v;
}


// Returns a steering vector towards targetDir
vec3 steerTowards(vec3 targetDir, vec3 velocity, float maxSteerForce)
{
	vec3 v = !isZero(targetDir) ? normalize(targetDir) * ubo.maxSpeed - velocity : velocity;
	return clampMagnitude(v, length(v), maxSteerForce);
}


// Source: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
vec2 rayBox(in vec3 orig, in vec3 dir, in vec3 extent, out vec3 oN) 
{
	vec3 m = 1.0/dir;
	vec3 n = m*orig;
	vec3 k = abs(m)*extent;

	vec3 t1 = -n - k;
	vec3 t2 = -n + k;

	float tn = max(max(t1.x, t1.y), t1.z);
	float tf = min(min(t2.x, t2.y), t2.z);

	if (tn > tf || tf < 0.0)
		return vec2(-1.0); // no intersection

	oN = -sign(dir) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);

	return vec2(tn, tf);
}


float rayBounds(in vec3 orig, in vec3 dir, in vec3 extent, out vec3 oN) 
{
	vec3 m = 1.0/dir;
	vec3 n = m*orig;
	vec3 k = abs(m)*extent;

	vec3 t1 = -n - k;
	vec3 t2 = -n + k;

	float tn = max(max(t1.x, t1.y), t1.z);
	float tf = min(min(t2.x, t2.y), t2.z);

	if (tn > tf)
		return -1.0;

	// Origin is inside box
	if (tn < 0.0 && tf > 0.0)
	{
		vec3 hit = orig + dir * tf;
		vec3 c = (-extent + extent) * 0.5;
		vec3 d = (-extent - extent) * 0.5;
		vec3 p = hit - c;

		// Inner collision normal
		vec3 n = vec3(p.x / abs(d.x), p.y / abs(d.y), p.z / abs(d.z)) * BIAS;
		oN = trunc(-n);

		return tf;
	}
	return -1.0;
}


// Old routine that does not utilize shared memory 
void computeForces(uint gid, vec3 position, out vec4 avoidanceHeading, out vec4 flockHeading, out vec4 flockCenter, out uint numFlockMates)
{
	uint idx = 0;
	for (uint i = 1; i < ubo.numBoids; i++) 
	{
		idx = (i + gid) % ubo.numBoids;

		vec4 other_pos = subo_in.boids[idx].position;
		vec4 other_dir = subo_in.boids[idx].velocity;
		other_dir = vec4(safeNormalize(other_dir.xyz), 1.0);

		vec3 offset = other_pos.xyz - position;
		float l1 = dot(offset, offset);

		if (l1 < ubo.viewRadius * ubo.viewRadius) 
		{
			numFlockMates++;
			flockHeading += other_dir;
			flockCenter += other_pos;

			if (l1 < ubo.avoidRadius * ubo.avoidRadius)
			{
				// Note that this can be a zero vector
				avoidanceHeading -= vec4(offset, 1.0) / l1;
			}
		}
	}
}


// Optimized routine that utilizes shared memory 
void computeForcesShared(uint gid, vec3 position, vec3 velocity, out vec4 avoidanceHeading, out vec4 flockHeading, out vec4 flockCenter, out uint numFlockMates)
{
	// Copy to fast shared data
	// Process in chunks of SHARED_DATA_SIZE
	uint local_id = gl_LocalInvocationID.x;
	uint group_size = gl_WorkGroupSize.x;
	for (uint i = 0; i < ubo.numBoids; i += group_size)
	{
		uint id = i + local_id;
		if (id < ubo.numBoids && id != gid)
		{
			sharedData[local_id].pos = subo_in.boids[id].position;
			sharedData[local_id].vel = subo_in.boids[id].velocity;
		}
		else 
		{
			// Mark invalid
			sharedData[local_id].pos.w = -1.0;
		}

		memoryBarrierShared();
		barrier();

		// Update force variables
		uint count = i < ubo.numBoids ? group_size : i-ubo.numBoids; 
		for (int j = 0; j < count; j++)
		{
			BoidData other = sharedData[j];
			if (other.pos.w < 0.0)
				continue;

			// Vision is a half sphere
			vec4 other_dir = vec4(safeNormalize(other.vel.xyz), 1.0);
			float lookdot = dot(normalize(velocity), normalize(other.pos.xyz - position));

			vec3 offset = other.pos.xyz - position;
			float l1 = dot(offset, offset);

			if (l1 < ubo.viewRadius * ubo.viewRadius && lookdot > 0.0) 
			{
				numFlockMates++;
				flockHeading += other_dir;
				flockCenter += other.pos;

				if (l1 < ubo.avoidRadius * ubo.avoidRadius)
				{
					// Note that this can be a zero vector
					avoidanceHeading -= vec4(offset, 1.0) / l1;
				}
			}
		}

		memoryBarrierShared();
		barrier();
	}
}


// SHADER MAIN
void main()
{
	// Fetch global compute shader invocation ID
	uint global_id = gl_GlobalInvocationID.x;

	// Read boid from input buffer - use the invocation ID as an index into our storage buffer
	Boid b = subo_in.boids[global_id];

	// Reset boid
	b.avoidanceHeading = vec4(0.0);
	b.flockHeading = vec4(0.0);
	b.flockCenter = vec4(0.0);
	b.numFlockMates = 0;

	computeForcesShared(global_id, b.position.xyz, b.velocity.xyz, b.avoidanceHeading, b.flockHeading, b.flockCenter, b.numFlockMates);
	//computeForces(global_id, b.position.xyz, b.avoidanceHeading, b.flockHeading, b.flockCenter, b.numFlockMates);

	// Calculate base acceleration determined by a moving global target position
	vec4 offset = vec4(ubo.target, 0.0) - b.position;
	vec3 acceleration = steerTowards(offset.xyz, b.velocity.xyz, ubo.maxSteerForce) * ubo.targetWeight;

	// Calculate individual forces (direction and magnitude)
	// 'alignment' indicates a force pushing towards the average heading of the flock
	// 'cohesion' indicates a force pushing towards the center of the flock
	// 'separation' indicates a force steering away from flock mates within an avoidance radius
	if (b.numFlockMates > 0)
	{
		vec4 average_flock_center = b.flockCenter / b.numFlockMates;
		vec4 average_flock_heading = b.flockHeading / b.numFlockMates;
		vec4 average_avoidance_heading = b.avoidanceHeading / b.numFlockMates;

		vec3 alignment = steerTowards(average_flock_heading.xyz, b.velocity.xyz, ubo.maxSteerForce) * ubo.alignmentWeight;
		vec3 cohesion = steerTowards(average_flock_center.xyz - b.position.xyz, b.velocity.xyz, ubo.maxSteerForce) * ubo.cohesionWeight;
		vec3 seperation = steerTowards(average_avoidance_heading.xyz, b.velocity.xyz, ubo.maxSteerForce) * ubo.separationWeight;

		acceleration += alignment;
		acceleration += cohesion;
		acceleration += seperation;
	}

	// Steer away from bounds
	vec3 hit_norm;
	float dist = rayBounds(b.position.xyz, normalize(b.velocity.xyz), vec3(ubo.boundsExtent), hit_norm);
	if (dist > -EPSILON && dist < ubo.avoidRadius*2.5)
	{
		vec3 ref = reflect(normalize(b.velocity.xyz), hit_norm);
		acceleration += steerTowards(ref, b.velocity.xyz, ubo.maxSteerForce*1.5) * avoidBoundWeightConst;
	}

	// Calculate velocity
	vec3 vel = clampMagnitude(b.velocity.xyz + acceleration * ubo.deltaTime, ubo.minSpeed, ubo.maxSteerForce);

	// Write current boid
	b.velocity.xyz = mix(vel, b.velocity.xyz, 0.5);
	b.position.xyz += b.velocity.xyz * ubo.deltaTime;

	// Get a quaternion describing the boid's delta rotation
	vec3 dir_orig = rotate(FORWARD, b.orientation);
	vec3 dir_dest = normalize(steerTowards(dir_orig, b.velocity.xyz, ubo.maxSteerForce));
	vec4 q_delta = rotationQuat(dir_orig, dir_dest);

	// Compose a new orientation from last frame's quat and the delta
	b.orientation = mulQuat(q_delta, b.orientation);

	// Write boid to output buffer
	subo_out.boids[global_id] = b;
}
