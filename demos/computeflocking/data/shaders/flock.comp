// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
#version 450

layout(local_size_x = 32) in;

struct Boid
{
	vec4 position;
	vec4 velocity;
	vec4 direction;

	vec4 avoidanceHeading;
	vec4 flockHeading;
	vec4 flockCenter;

	// Padding member
	uint padding[3];

	// Maintain 16 byte-alignment
	uint numFlockMates;
};

struct BoidTransform
{
	vec4 translation;
	vec4 rotation;
};


// STORAGE
layout(std430) buffer BoidBuffer_In
{
	Boid boids[1000];
} subo_in;

layout(std430) buffer BoidBuffer_Out
{
	Boid boids[1000];
} subo_out;

// Bound to vertex shader 'boids.vert'
layout(std430) buffer TransformBuffer
{
	BoidTransform transforms[1000];
};


// UNIFORM
uniform UBO 
{
	vec3 target;
	float deltaTime;
	float elapsedTime;
	float viewRadius;
	float avoidRadius;
	float minSpeed;
	float maxSpeed;
	float maxSteerForce;
	float targetWeight;
	float alignmentWeight;
	float cohesionWeight;
	float separationWeight;
	int numBoids;
} ubo;


// CONSTANTS
const float PI 				= 3.141592;
const float EPSILON 		= 0.00001;
const vec4 QUAT_IDENTITY 	= vec4(0.0, 0.0, 0.0, 1.0);
const vec3 FORWARD 			= vec3(0.0, 0.0, 1.0);
const vec3 UP 				= vec3(0.0, 1.0, 0.0);
const vec3 RIGHT 			= vec3(1.0, 0.0, 0.0);


// Multiply two quaternions -> qa * qb
vec4 mulQuat(vec4 qa, vec4 qb)
{ 
	return normalize(vec4(
		qb.xyz * qa.w + qa.xyz * qb.w + cross(qa.xyz, qb.xyz),
		qa.w * qb.w - dot(qa.xyz, qb.xyz)
	));
}


// Inverse 
vec4 invertQuat(vec4 q) 
{ 
	return vec4(-q.x, -q.y, -q.z, q.w); 
} 


// Rotate vector v with quaterion q
vec3 rotate(vec3 v, vec4 q)
{
	float l1 = dot(q.xyz, q.xyz);
	return v * (q.w * q.w - l1) + q.xyz * (dot(v, q.xyz) * 2.0) + cross(q.xyz, v) * (q.w * 2.0);
}


// Returns a quaternion describing a rotation from orig to dest
vec4 rotationQuat(vec3 orig, vec3 dest)
{
	float cos_theta = dot(orig, dest);
	if (cos_theta >= 1.0-EPSILON)
		return QUAT_IDENTITY;

	vec3 rot_axis = cross(orig, dest);
	float s = sqrt((1.0+cos_theta)*2.0);
	float invs = 1.0 / s;

	return vec4(
		rot_axis.x * invs,
		rot_axis.y * invs,
		rot_axis.z * invs,
		s * 0.5
	);
}


// Returns true if v is a zero-vector, otherwise false
bool isZero(vec3 v)
{
	float valid = 1.0;

	valid *= step(-EPSILON, v.x) * (1.0 - step(EPSILON, v.x));
	valid *= step(-EPSILON, v.y) * (1.0 - step(EPSILON, v.y));
	valid *= step(-EPSILON, v.z) * (1.0 - step(EPSILON, v.z));

	return bool(valid);
}


// Returns a zero vector instead of nan if v cannot be normalized, otherwise normalizes v
vec3 safeNormalize(vec3 v)
{
	return !isZero(v) ? normalize(v) : vec3(0.0);
}


// Clamps the magnitude of v between min and max
vec3 clampMagnitude(vec3 v, float min, float max)
{
	if (length(v) > max)
		return normalize(v) * max;
	else if (length(v) < min)
		return normalize(v) * min;

	return v;
}


// Returns a steering vector towards targetDir
vec3 steerTowards(vec3 targetDir, vec3 velocity, float maxSpeed)
{
	vec3 v = !isZero(targetDir) ? normalize(targetDir) * maxSpeed - velocity : velocity;
	return clampMagnitude(v, length(v), ubo.maxSteerForce);
}


// SHADER MAIN
void main()
{
	uint id = gl_GlobalInvocationID.x;

	// Read current boid
	Boid b = subo_in.boids[id];

	// Reset boid
	b.avoidanceHeading = vec4(0.0);
	b.flockHeading = vec4(0.0);
	b.flockCenter = vec4(0.0);
	b.numFlockMates = 0;

	// Update force variables
	for (int idx = 0; idx < ubo.numBoids; idx++) 
	{
		if (idx != id)
		{
			vec4 other_pos = subo_in.boids[idx].position;
			vec4 other_dir = subo_in.boids[idx].velocity;
			other_dir = vec4(safeNormalize(other_dir.xyz), 1.0);

			vec3 offset = other_pos.xyz - b.position.xyz;
			float l1 = dot(offset, offset);

			if (l1 < ubo.viewRadius * ubo.viewRadius) 
			{
				b.numFlockMates++;
				b.flockHeading += other_dir;
				b.flockCenter += other_pos;

				if (l1 < ubo.avoidRadius * ubo.avoidRadius)
				{
					// Note that this can be a zero vector
					b.avoidanceHeading -= vec4(offset, 1.0) / l1;
				}
			}
		}
	}

	// Calculate base acceleration
	vec4 offset = vec4(ubo.target, 0.0) - b.position;
	vec3 acceleration = steerTowards(offset.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.targetWeight;

	// Calculate forces
	if (b.numFlockMates > 0) 	
	{
		vec4 average_flock_center = b.flockCenter / b.numFlockMates;
		vec4 average_flock_heading = b.flockHeading / b.numFlockMates;
		vec4 average_avoidance_heading = b.avoidanceHeading / b.numFlockMates;

		vec3 alignment = steerTowards(average_flock_heading.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.alignmentWeight;
		vec3 cohesion = steerTowards(average_flock_center.xyz - b.position.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.cohesionWeight;
		vec3 seperation = steerTowards(average_avoidance_heading.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.separationWeight;

		acceleration += alignment;
		acceleration += cohesion;
		acceleration += seperation;
	}

	// Calculate velocity
	vec3 vel = clampMagnitude(b.velocity.xyz + acceleration * ubo.deltaTime, ubo.minSpeed, ubo.maxSpeed);

	// Write current boid
	b.velocity.xyz = mix(vel, b.velocity.xyz, 0.5);
	b.direction.xyz = normalize(steerTowards(b.direction.xyz, b.velocity.xyz, 0.005));
	b.position.xyz += b.velocity.xyz * ubo.deltaTime;

	// Create boid transform
	BoidTransform bt;
	bt.translation = b.position;

	// Calculate quaternion describing a rotation from the forward direction to the current direction
	bt.rotation = rotationQuat(FORWARD, b.direction.xyz);

	// Set boid
	subo_out.boids[id] = b;

	// Set boid transform
	transforms[id] = bt;
}
