// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
#version 450

layout(local_size_x = 8) in;

struct Boid
{
	vec4 position;
	vec4 velocity;
	vec4 direction;

	vec4 avoidanceHeading;
	vec4 flockHeading;
	vec4 flockCenter;

	// Padding member
	int padding[3];

	// Maintain 16 byte-alignment
	int numFlockMates;
};


// STORAGE

layout(std430) buffer BoidBuffer_In
{
	Boid boids[1000];
} subo_in;

layout(std430) buffer BoidBuffer_Out
{
	Boid boids[1000];
} subo_out;

layout(std430) buffer MatrixBuffer
{
	mat4 transforms[1000];
};


// UNIFORM

uniform UBO 
{
	vec3 target;
	float deltaTime;
	float elapsedTime;
	float viewRadius;
	float avoidRadius;
	float minSpeed;
	float maxSpeed;
	float maxSteerForce;
	float targetWeight;
	float alignmentWeight;
	float cohesionWeight;
	float separationWeight;
	int numBoids;
} ubo;


// CONSTANTS

const float EPSILON = 0.00001;
const vec4 QUAT_IDENTITY = vec4(0.0, 0.0, 0.0, 1.0);
const vec3 FORWARD_AXIS = vec3(0.0, 0.0, -1.0);
const vec3 UP_AXIS = vec3(0.0, 1.0, 0.0);
const vec3 X_AXIS = vec3(1.0, 0.0, 0.0);
const vec3 Y_AXIS = vec3(0.0, 1.0, 0.0);
const vec3 Z_AXIS = vec3(0.0, 0.0, 1.0);


mat4 translate(vec3 d)
{
	return mat4(
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		d.x, d.y, d.z, 1.0
	);
}


mat4 lookAt(vec3 from, vec3 to)
{
	vec3 forward = normalize(to - from);
	vec3 up = UP_AXIS;

	if(abs(forward.x) < EPSILON && abs(forward.z) < EPSILON)
		up = (forward.y > 0.0) ? vec3(0.0, 0.0, -1.0) : vec3(0.0, 0.0, 1.0);
	else
		up = vec3(0.0, 1.0, 0.0);

	vec3 right = normalize(cross(up, forward));
	up = normalize(cross(forward, right));

	return mat4(
		right.x,	right.y,	right.z,	0.0,
		up.x,		up.y,		up.z,		0.0,
		forward.x,	forward.y,	forward.z,	0.0,
		0.0, 		0.0,		0.0,		1.0
	);
}


bool isZero(vec3 v)
{
	float valid = 1.0;

	valid *= step(-EPSILON, v.x) * (1.0 - step(EPSILON, v.x));
	valid *= step(-EPSILON, v.y) * (1.0 - step(EPSILON, v.y));
	valid *= step(-EPSILON, v.z) * (1.0 - step(EPSILON, v.z));

	return bool(valid);
}


vec3 clampMagnitude(vec3 v, float min, float max)
{
	if (length(v) > max)
		return normalize(v) * max;
	else if (length(v) < min)
		return normalize(v) * min;

	return v;
}


vec3 steerTowards(vec3 targetDir, vec3 velocity, float maxSpeed)
{
	if (isZero(targetDir))
		return velocity;

	vec3 v = normalize(targetDir) * maxSpeed - velocity;
	return clampMagnitude(v, length(v), ubo.maxSteerForce);
}


// SHADER MAIN

void main()
{
	uint id = gl_GlobalInvocationID.x;

	// Read current boid
	Boid b = subo_in.boids[id];

	// Reset num flock mates
	b.numFlockMates = 0;

	// Update force variables
	for (int idx = 0; idx < ubo.numBoids; idx++) 
	{
		if (id != idx) 
		{
			vec4 other_position = subo_in.boids[idx].position;
			vec4 other_direction = normalize(subo_in.boids[idx].velocity);

			vec4 offset = other_position - b.position;
			float distance_squared = offset.x * offset.x + offset.y * offset.y + offset.z * offset.z;

			if (distance_squared < ubo.viewRadius * ubo.viewRadius) 
			{
				b.numFlockMates++;
				b.flockHeading += other_direction;
				b.flockCenter += other_position;

				if (distance_squared < ubo.avoidRadius * ubo.avoidRadius)
				{
					// Note that this value can be (0.0, 0.0, 0.0)
					b.avoidanceHeading -= offset / distance_squared;
				}
			}
		}
	}

	// Calculate base acceleration
	vec4 offset = vec4(ubo.target, 0.0) - b.position;
	vec3 acceleration = steerTowards(offset.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.targetWeight;

	// Calculate forces
	if (b.numFlockMates > 0) 
	{
		vec4 average_flock_center = b.flockCenter / b.numFlockMates;
		vec4 average_flock_heading = b.flockHeading / b.numFlockMates;
		vec4 average_avoidance_heading = b.avoidanceHeading / b.numFlockMates;

		vec3 alignment = steerTowards(average_flock_heading.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.alignmentWeight;
		vec3 cohesion = steerTowards(average_flock_center.xyz - b.position.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.cohesionWeight;
		vec3 seperation = steerTowards(average_avoidance_heading.xyz, b.velocity.xyz, ubo.maxSpeed) * ubo.separationWeight;

		acceleration += alignment;
		acceleration += cohesion;
		acceleration += seperation;
	}

	// Write current boid
	vec3 vel = clampMagnitude(b.velocity.xyz + acceleration * ubo.deltaTime, ubo.minSpeed, ubo.maxSpeed);
	b.velocity = mix(vec4(vel, 0.0), b.velocity, 0.5);
	b.direction = vec4(steerTowards(b.direction.xyz, b.velocity.xyz, ubo.maxSteerForce), 0.0);
	b.position += b.velocity * ubo.deltaTime;

	subo_out.boids[id] = b;

	// Calculate transformation matrices
	// Apply particle translation / rotation
	mat4 translation = translate(b.position.xyz);
	mat4 rotation = lookAt(FORWARD_AXIS, normalize(b.direction.xyz));

	// Matrix storage buffer
	transforms[id] = translation * rotation;
}
