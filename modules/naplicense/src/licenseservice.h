/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

#pragma once

// Local Includes
#include "publickey.h"
 
 // External Includes
#include <nap/service.h>
#include <nap/datetime.h>

namespace nap
{
	// Forward Declares
	class LicenseService;

	/**
	 * Allows the user of an application to enter a license and key.
	 * The license and key must be generated using the 'licensegenerator'
	 */
	class NAPAPI LicenseConfiguration : public ServiceConfiguration
	{
		RTTI_ENABLE(ServiceConfiguration)
	public:
		std::string mLicense;				///< Property: 'License' path to the '.license' file, generated by the 'licensegenerator'
		std::string mKey;					///< Property: 'Key' path to the '.key' file, generated by the 'licensegenerator'

		virtual rtti::TypeInfo getServiceType() override { return RTTI_OF(LicenseService); }
	};


	/**
	 * Validated user license information
	 */
	struct NAPAPI LicenseInformation
	{
		std::string		mName;					///< Extracted user name
		std::string		mMail;					///< Extracted user mail
		std::string		mApp;					///< Extracted application signature
		Date			mDate;					///< License expiry date

		/**
		 * @return if the license can expire
		 */
		bool canExpire() const					{ return mDate.mMonth != EMonth::Unknown; }
	};


	/**
	 * Validates a license using a nap::PublicKey.
	 */
	class NAPAPI LicenseService : public Service
	{
		RTTI_ENABLE(Service)
	public:
		/**
		 *	Default constructor
		 */
		LicenseService(ServiceConfiguration* configuration);

		/**
		 *	Explicitly frees the yoctopuce API
		 */
		virtual ~LicenseService() override;

		/**
		 * Validates the user provided license using a public RSA key.
		 * Call this somewhere in your application, preferably on init(), to ensure the user provided license is valid.
		 *
		 * The license is valid when:
		 * - a key and license file is provided by the user, using the LicenseConfiguration
		 * - it can be verified using the provided public key
		 * - it is not expired
		 *
		 * Note that a license, without an expiration date, is considered valid after it passes verification.
		 * It is up to the owner of the application to create and sign a license with an expiration date if required.
		 *
		 * @param publicKey public key, generated using the 'licensegenerator'
		 * @param outInformation validated user license information, empty if license is invalid
		 * @param error explains why the license is not valid
		 * @return if this app has a valid license
		 */
		bool validateLicense(const nap::PublicKey& key, LicenseInformation& outInformation, utility::ErrorState& error);

		/**
		 * Returns if the user provided a license. Does not mean it is valid.
		 * @return if a license is provided by the user.
		 */
		bool hasLicense() const						{ return !mLicense.empty(); }

		/**
		 * @return license file path
		 */
		const std::string& getLicense() const		{ return mLicense; }

		/**
		 * Returns if the user provided a key (signature). Does not mean it is valid.
		 * @return if a key (signature) is provided by the user
		 */
		bool hasKey() const							{ return !mSignature.empty(); }

		/**
		 * @return key (signature) file path
		 */
		const std::string& getKey() const			{ return mSignature; }

	protected:
		/**
		 * Initializes the license service.
		 * Note that it does not check license validity at this point, you
		 * have to do that yourself by calling validateLicense(), together with a public RSA key.
		 * @param error contains the error if initialization fails
		 * @return if initialization succeeded
		 */
		virtual bool init(utility::ErrorState& error) override;

	private:
		std::string mLicense;			///< Human readable license file path
		std::string mSignature;			///< License signature file path

		bool RSAVerifyFile(const std::string& publicKey, const std::string& licenseFile, const std::string& signatureFile);
		void setArgument(const std::unordered_map<std::string, std::string>& args, const std::string& key, std::string& outValue);
		bool getExpirationDate(const std::string& date, SystemTimeStamp& outDate, utility::ErrorState& error);
	};
}
