// NAP Shader include file

// Poisson Sampling
const vec2 POISSON_DISK_1[1] = vec2[](
	vec2(0.0, 0.0)
);

const vec2 POISSON_DISK_4[4] = vec2[](
	vec2(-0.94201624, -0.39906216),
	vec2(0.94558609, -0.76890725),
	vec2(-0.094184101, -0.92938870),
	vec2(0.34495938, 0.29387760)
);

const vec2 POISSON_DISK_16[16] = vec2[](
	vec2( -0.94201624, -0.39906216 ),
	vec2( 0.94558609, -0.76890725 ),
	vec2( -0.094184101, -0.92938870 ),
	vec2( 0.34495938, 0.29387760 ),
	vec2( -0.91588581, 0.45771432 ),
	vec2( -0.81544232, -0.87912464 ),
	vec2( -0.38277543, 0.27676845 ),
	vec2( 0.97484398, 0.75648379 ),
	vec2( 0.44323325, -0.97511554 ),
	vec2( 0.53742981, -0.47373420 ),
	vec2( -0.26496911, -0.41893023 ),
	vec2( 0.79197514, 0.19090188 ),
	vec2( -0.24188840, 0.99706507 ),
	vec2( -0.81409955, 0.91437590 ),
	vec2( 0.19984126, 0.78641367 ),
	vec2( 0.14383161, -0.14100790 )
);

const float POISSON_SPREAD 	= 768.0;

// Calculate shadow contribution
// @param shadowCoord: the fragment position in light space
// @param lightDir: the light direction
float computeShadow(sampler2DShadow shadowMap, vec4 shadowCoord, vec3 lightDir, vec3 surfNormal, uint lightIndex)
{
	// Map coordinates to [0.0, 1.0] range
	shadowCoord = shadowCoord * 0.5 + 0.5;

	const float texelSize = 1.0/float(textureSize(shadowMap, 0).x);
	float bias = max(0.25 * texelSize * (1.0 - dot(surfNormal, lightDir)), texelSize);
	float frag_depth = (shadowCoord.z-bias) / shadowCoord.w;
	float shadow = 0.0;

	// Multi sample
	for (int i=0; i<POISSON_DISK_16.length(); i++) 
	{
		shadow += 1.0 - texture(shadowMap, 
			vec3(shadowCoord.xy + POISSON_DISK_16[i]/POISSON_SPREAD, frag_depth)
		);
	}
	shadow /= float(POISSON_DISK_16.length());

	// Single sample
	//shadow = 1.0 - texture(shadowMaps[lightIndex], vec3(shadowCoord.xy, frag_depth));

	return shadow;
}
