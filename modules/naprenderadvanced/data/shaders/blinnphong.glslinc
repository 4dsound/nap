// NAP Shader include file

// Includes
#include "light.glslinc"

// Material structs
struct BlinnPhongMaterial
{
	vec3	ambient;				//< Ambient
	vec3	diffuse;				//< Diffuse
	vec3	specular;				//< Specular
	float	shininess;				//< Shininess
};


// Shades a fragment based on a light, incoming normal and position should be in object space
vec3 computeLight(vec3 lightDirection, vec3 lightColor, float lightIntensity, float strength, BlinnPhongMaterial mtl, vec3 camPosition, vec3 surfNormal, vec3 fragPosition)
{
	// inverse light direction
	vec3 inv_dir = normalize(-lightDirection);

	// calculate vector that defines the distance from camera to the surface
	vec3 surface_to_cam = normalize(camPosition - fragPosition);

	// lighting components
	float diffuse = max(0.0, dot(surfNormal, inv_dir));
	float specular = 0.0;

	// compute specular value if diffuse coefficient is > 0.0
	if (diffuse > 0.0)
	{
		vec3 halfway = normalize(inv_dir + surface_to_cam);  
		specular = pow(max(dot(surfNormal, halfway), 0.0), mtl.shininess);
	}

	vec3 ambient_color = lightIntensity * mtl.ambient;
	vec3 diffuse_color = diffuse * lightIntensity * mtl.diffuse;
	vec3 specular_color = specular * lightIntensity * mtl.specular;

	// linear color (color before gamma correction)
	vec3 comp_color = (diffuse_color + specular_color + ambient_color) * strength;

	// clamp
	return clamp(comp_color, 0.0, 1.0);
}


// Shades a fragment based on a light, incoming normal and position should be in object space
vec3 computeLightDirectional(DirectionalLight lights[8], uint count, BlinnPhongMaterial mtl, vec3 camPosition, vec3 surfNormal, vec3 fragPosition)
{
	vec3 color = { 0.0, 0.0, 0.0 };
	for (uint i = 0; i < count; i++)
	{
		DirectionalLight li = lights[i];
		color += computeLight(li.direction, li.color, li.intensity, 1.0, mtl, camPosition, surfNormal, fragPosition);
	}
	return color;
}


vec3 computeLightDirectional(DirectionalLight light, BlinnPhongMaterial mtl, vec3 camPosition, vec3 surfNormal, vec3 fragPosition)
{
	return computeLight(light.direction, light.color, 1.0, light.intensity, mtl, camPosition, surfNormal, fragPosition);
}


// Single point light
vec3 computeLightPoint(vec3 lightPosition, vec3 lightColor, float lightIntensity, BlinnPhongMaterial mtl, vec3 camPosition, vec3 surfNormal, vec3 fragPosition)
{
	vec3 delta = fragPosition - lightPosition;
	float dist_squared = dot(delta, delta);
	float atten = 0.05/dist_squared;
	return computeLight(normalize(delta), lightColor, lightIntensity, atten, mtl, camPosition, surfNormal, fragPosition);
}


// Multiple point lights
vec3 computeLightPoint(PointLight lights[8], uint count, BlinnPhongMaterial mtl, vec3 camPosition, vec3 surfNormal, vec3 fragPosition)
{
	vec3 color = { 0.0, 0.0, 0.0 };
	for (uint i = 0; i < count; i++)
	{
		PointLight li = lights[i];
		vec3 dir = normalize(fragPosition - li.origin);
		color += computeLightPoint(dir, li.color, li.intensity, mtl, camPosition, surfNormal, fragPosition);
	}
	return color;
}


