#!/usr/bin/python

import argparse
import json
import os
import sys

PROJECT_INFO_FILENAME = 'project.json'
PROJECT_INFO_CMAKE_CACHE_FILENAME = 'cached_project_json.cmake'

def update_project_info_to_cmake(project_path):
    # Check our project exists
    assert os.path.exists(project_path), 'Project path not found: %s' % project_path

    output_filename = os.path.join(project_path, PROJECT_INFO_CMAKE_CACHE_FILENAME)

    # If any existing output file exists remove it.  This ensure that CMake will fail if our JSON parsing etc fails.
    if os.path.exists(output_filename):
        os.remove(output_filename)

    # Read in the JSON
    project_filename = os.path.join(project_path, PROJECT_INFO_FILENAME)
    with open(project_filename) as json_file:
        try:
            json_dict = json.load(json_file)
        except json.JSONDecodeError as e:
            raise Exception('While opening %s: %s' % (project_filename, e))

    modulelist = json_dict.get('modules', [])
    assert isinstance(modulelist, list), "Expected list 'modules' in %s, got %s" %\
                                         (project_filename, type(modulelist))
    nap_modules = ' '.join(modulelist)

    # Write out
    with open(output_filename, 'w') as out_file:
        out_file.write("# Don't edit this file\n")
        out_file.write("#\n# It was auto generated by cmake from project.json which should be edited instead\n\n")
        out_file.write("set(NAP_MODULES %s)\n" % nap_modules)

def update_projectjson_modulepaths(project_path, module_path):
    """Ensure the lib directory is listed in the project.json file so the executables can find their dependencies.

    :param project_path: Absolute path to the project directory
    :param module_path: Absolute path to the module directory (where the shared objects/dlls are)
    """

    filename = os.path.join(project_path, PROJECT_INFO_FILENAME)
    assert os.path.exists(filename), 'File not found: %s' % filename

    with open(filename, 'r') as fp:
        data = json.load(fp)

    # module path is preferably relative to project.json directory
    relmodulepath = os.path.relpath(module_path, project_path)

    # just set the module paths to the current lib output path, multiple paths are allowed too
    if data.get('modulepaths') != [relmodulepath]:
        data['modulepaths'] = [relmodulepath]

        with open(filename, 'w') as fp:
            json.dump(data, fp, indent=4)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('PROJECT_NAME')
    # parser.add_argument('MODULE_PATH')
    args = parser.parse_args()

    update_project_info_to_cmake(args.PROJECT_NAME)
    # update_projectjson_modulepaths(args.PROJECT_NAME, args.MODULE_PATH)
